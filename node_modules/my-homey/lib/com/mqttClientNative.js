'use strict';

const MQTT = require('async-mqtt');

const SimpleClass = require('../myLayer/SimpleClass');

const BIRTH_PAYLOAD = 'true';
const WILL_PAYLOAD = 'false';

module.exports = class MqttClient extends SimpleClass {

  #client = null;
  #retainMessages = {};

  constructor(owner, rootTopic = 'homey', options = {}) {
    super(owner);
    this.rootTopic = rootTopic;
    this.options = {
      ...{
        connectTimeout: 4000,
        reconnectPeriod: 5000,
        will: {
          topic: `${this.rootTopic}/online`,
          payload: WILL_PAYLOAD,
          qos: 1,
          retain: true,
        },
      },
      ...options,
    };

    this.logDebug('initialized');
  }

  // Homey-Logger

  debug(msg) {
    // Enable only for test
    // super.debug(msg);
  }

  // MQTT events

  onMessage(topic, msg) {
    const message = msg.toString();
    this.logDebug(`onMessage() > topic: ${topic} message: ${message}`);
    this.emit('message', topic, message);
  }

  onConnect() {
    this.logDebug('onConnect()');
    if (!this.#client) {
      this.#publishBirthMessage();
    }
  }

  onReconnect() {
    this.logDebug('onReconnect()');
    // this.#publishBirthMessage();
  }

  onClose() {
    this.logDebug('onClose()');
  }

  onDisconnect() {
    this.logDebug('onDisconnect() > MQTT 5.0 feature');
  }

  onOffline() {
    this.logDebug('onOffline()');
  }

  onError(error) {
    this.logError(`onError() > ${error}`);
  }

  onEnd() {
    this.logDebug('onEnd()');
  }

  // MQTT API

  async connect(url = 'mqtt://localhost:1883') {
    this.logDebug(`connect() > url: ${url}, options: ${JSON.stringify(this.options)}`);

    // @ts-ignore
    this.#client = await MQTT.connectAsync(url, this.options)
      .catch((error) => {
        this.logError(`connect() > ${error}`);
        throw Error(error);
      });

    this.#client
      .on('message', this.onMessage.bind(this))
      .on('connect', this.onConnect.bind(this))
      .on('reconnect', this.onReconnect.bind(this))
      .on('close', this.onClose.bind(this))
      .on('disconnect', this.onDisconnect.bind(this))
      .on('offline', this.onOffline.bind(this))
      .on('error', this.onError.bind(this))
      .on('end', this.onEnd.bind(this));

    this.#publishBirthMessage();
  }

  publish(topic, message, options = {}) {
    this.logDebug(`publish() > options: ${JSON.stringify(options)}, topic: ${topic}, message: "${message}"`);

    if (options.retain && topic in this.#retainMessages && this.#retainMessages[topic] === message) {
      this.logDebug(`publish() > Message already sent > topic: ${topic}, message: "${message}"`);
      return Promise.resolve(true);
    }

    return this.#client.publish(topic, message, options)
      .then(() => {
        if (options.retain) {
          this.#retainMessages[topic] = message;
        }
      })
      .catch((error) => {
        this.logError(`publish() > ${error}`);
        throw Error(error);
      });
  }

  subscribe(topic, options = {}) {
    this.logDebug(`subscribe() > options: ${JSON.stringify(options)}, topic: ${typeof topic === 'string' ? topic : JSON.stringify(topic)}`);

    return this.#client.subscribe(topic, options)
      .catch((error) => {
        this.logError(`subscribe() > ${error}`);
        throw Error(error);
      });
  }

  unsubscribe(topic, options = {}) {
    this.logDebug(`unsubscribe() > options: ${JSON.stringify(options)}, topic: ${typeof topic === 'string' ? topic : JSON.stringify(topic)}`);

    return this.#client.unsubscribe(topic, options)
      .catch((error) => {
        this.logError(`unsubscribe() > ${error}`);
        throw Error(error);
      });
  }

  // myMQTT API

  clearAllRetainMessages() {
    this.logDebug('clearAllRetainMessages()');

    Object.keys(this.#retainMessages)
      .forEach((topic) => this.#clear(topic));

    return Promise.resolve(true);
  }

  clearRetainMessages(subTopic, qos = 0) {
    this.logDebug(`clearRetainMessages() > topic: ${subTopic}`);

    Object.keys(this.#retainMessages)
      .filter((topic) => topic.startsWith(subTopic))
      .forEach((topic) => this.#clear(topic));

    return Promise.resolve(true);
  }

  #clear(topic, qos = 0) {
    this.logDebug(`#clear() > topic: ${topic} qos: ${qos}`);
    return this.publish(topic, null, { qos, retain: true })
      .then(() => {
        delete this.#retainMessages[topic];
      });
  }

  async #publishBirthMessage() {
    this.logDebug('#publishBirthMessage()');
    await this.#client.publish(this.options.will.topic, BIRTH_PAYLOAD, { retain: this.options.will.retain, qos: this.options.will.qos });
  }

};
