'use strict';

const SimpleClass = require('../myLayer/SimpleClass');

const MqttClientApp = require('../appWrapper/mqttClientApp');

const BIRTH_PAYLOAD = 'true';
const WILL_PAYLOAD = 'false';

module.exports = class MqttClient extends SimpleClass {

  #client = null;
  #retainMessages = {};

  constructor(owner, rootTopic = 'homey', options = {}) {
    super(owner);
    this.rootTopic = rootTopic;

    this.options = {
      ...{
        connectTimeout: 4000,
        reconnectPeriod: 5000,
        will: {
          topic: `${this.rootTopic}/online`,
          payload: WILL_PAYLOAD,
          qos: 1,
          retain: true,
        },
      },
      ...options,
    };

    this.#client = MqttClientApp.getInstance(this);
    this.#client
      .on('message', this.onMessage.bind(this))
      .on('connect', this.onConnect.bind(this))
      .on('disconnect', this.onDisconnect.bind(this));

    this.logDebug('initialized');
  }

  // MqttClientApp - API

  onMessage(topic, message) {
    this.logDebug('onMessage()');
    this.emit('message', topic, message);
  }

  onConnect() {
    this.logDebug('onConnect()');
  }

  onDisconnect() {
    this.logDebug('onDisconnect()');
  }

  // MqttClientApp - API

  async connect() {
    this.logDebug('connect()');
    return this.#client.connect();
  }

  async disconnect() {
    this.logDebug('disconnect()');
    return this.#client.disconnect();
  }

  publish(topic, message, options = {}) {
    this.logDebug(`publish() > options: ${JSON.stringify(options)}, topic: ${topic}, message: "${message}"`);

    if (options.retain && topic in this.#retainMessages && this.#retainMessages[topic] === message) {
      this.logDebug(`publish() > Message already sent > topic: ${topic}, message: "${message}"`);
      return Promise.resolve(true);
    }

    const mqttMsg = this.#getMqttMessage(topic, message, options);

    return this.#client.publish(mqttMsg)
      .then(() => {
        if (options.retain) {
          this.#retainMessages[topic] = message;
          // this.#retainMessages[topic] = 'sendEachMessage';
        }
      })
      .catch((error) => {
        this.logError(`publish() > ${error}`);
        throw Error(error);
      });
  }

  subscribe(topic, options = {}) {
    this.logDebug(`subscribe() > options: ${JSON.stringify(options)}, topic: ${typeof topic === 'string' ? topic : JSON.stringify(topic)}`);

    return this.#client.subscribe(topic)
      .catch((error) => {
        this.logError(`subscribe() > ${error}`);
        throw Error(error);
      });
  }

  unsubscribe(topic, options = {}) {
    this.logDebug(`unsubscribe() > options: ${JSON.stringify(options)}, topic: ${typeof topic === 'string' ? topic : JSON.stringify(topic)}`);

    return this.#client.unsubscribe(topic)
      .catch((error) => {
        this.logError(`unsubscribe() > ${error}`);
        throw Error(error);
      });
  }

  // myMQTT API

  clearAllRetainMessages() {
    this.logDebug('clearAllRetainMessages()');

    Object.keys(this.#retainMessages)
      .forEach((topic) => this.#clear(topic));

    return Promise.resolve(true);
  }

  clearRetainMessages(subTopic, qos = 0) {
    this.logDebug(`clearRetainMessages() > topic: ${subTopic}`);

    Object.keys(this.#retainMessages)
      .filter((topic) => topic.startsWith(subTopic))
      .forEach((topic) => this.#clear(topic));

    return Promise.resolve(true);
  }

  #clear(topic, qos = 0) {
    this.logDebug(`#clear() > topic: ${topic} qos: ${qos}`);
    return this.publish(topic, null, { qos, retain: true })
      .then(() => {
        delete this.#retainMessages[topic];
      });
  }

  async #publishBirthMessage() {
    this.logDebug('#publishBirthMessage()');
    await this.#client.publish(this.options.will.topic, BIRTH_PAYLOAD, { retain: this.options.will.retain, qos: this.options.will.qos });
  }

  #getMqttMessage(topic, message, options) {
    return {
      qos: options.qos || 0,
      retain: options.retain || false,
      mqttTopic: typeof topic === 'string' ? topic : (topic || '').toString(),
      mqttMessage: message,
    };
  }

};
